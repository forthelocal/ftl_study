# 開発クオリティ向上のためのノウハウ講義
## 第一回目 ノウハウ体系の脳内マップ

---
# 日々の業務で感じる問題
我々は日々、仕事でシステムを開発している
* システムを設計し、プログラムのコードを書く
* 他のスタッフの書いたコードのレビューをする
* 不明瞭な仕様についてどう対応するか判断する

これらには唯一の正解というものがなく、各スタッフによって方法論がまちまちになりがち。
↓
これらをより高クオリティに効率よく行えるように、根拠となるノウハウの体系を蓄積したい。
↓
今回の講義はその概要部分を解説しようというもの。

---
# 今回の講義の目的
* 今後、開発クオリティ向上のためのノウハウを蓄積していく。
* それにあたり、各具体的な技術の解説に入る前に、それらが大目的に対してどのような位置づけと役割を持つのかを把握できるような脳内マップを提供する。
* ここで言う脳内マップとは、Webサイトにおけるサイトマップのように、樹形的に整理された小規模な構造のことである。

---
# 脳内マップ
```
[目的]クオリティの高い開発を効率良く行う
  ├ [知識編] 変更の容易なプログラムを作るための知識
  │    ├ 依存性の低さ
  │    ├ わかりやすさ
  │    └ 再利用性の高さ
  └ [実践編] 効率の良い開発をするための技術
       ├ 遅延設計
       └ チームのメンバーの行動を予測する
```

---
## 脳内マップ 各論技術の例をいくつか挿入
```
[目的]クオリティの高い開発を効率良く行う
  ├ [知識編] 変更の容易なプログラムを作るための知識
  │    ├ 依存性の低さ
  │    │    - 'データ構造体の隔離'
  │    │    - 'インターフェイスの利用'
  │    ├ わかりやすさ
  │    │    - 'リーダブルコード'
  │    └ 再利用性の高さ
  │         - 'メソッドの単一責任化'
  └ [実践編] 効率の良い開発をするための技術
       ├ 遅延設計
       │    - '設計のしすぎ問題'
       └ チームのメンバーの行動を予測する
            - 'メンバーは既存コードを模範としてコードを書く'
```

---
# 良いプログラムとはなにか
* 動作が早いこと？
* 行数が少ないこと？
* 詳細なコメントが書いてあること？

↓
先人の経験や研究によって一定の見解が出ている。

↓
良いプログラムとは **「変更が容易」** なプログラムである。


---
# プログラムは必ず変更が求められる
開発では変更とうまく付き合うことが重要である。

## 変更の発生する原因例
- 依頼者が自分の望みをわかっていなかった
- 開発者が依頼者の望みを理解できていなかった
- 開発者がよりよい方法を思いついた
- 法律やビジネス環境が変わり要件の変更が必要になった
- プログラミング言語、フレームワークのアップデート
 ...

要件レベルでの変更が必要なものから、小改修レベルのものまで、
アプリケーションには常に **変更が求められ続ける** 。

---
# [知識編] 変更の容易なプログラムを作るための知識

---
# 「変更が容易」なプログラムのために
プログラムを作成する際、以下の条件を満たすものが「変更が容易」で、良いプログラムである。
* [依存性が低い]
  * 利点例 : 変更により副作用が伝播する範囲が最小限で済む
* [わかりやすい]
  * 利点例 : 変更すべき箇所がコードを見ればすぐに分かる
* [再利用性が高い]
  * 利点例 : 変更・修正箇所が最小限で済む

---
# 変更が難しいプログラム
* [依存性が高い]
  * ちょっとした変更が思わぬ箇所のバグを誘発する
  * 少しの変更のために多くの箇所を修正しなくてはならない
* [わかりにくい]
  * コードを見てもなにをしているのかを理解することが難しく、変更・修正のたびにコードの解読のコストがかかる
* [再利用性が低い]
  * 同じ内容の処理が複数の箇所にコピペされていて、同内容の変更のためにそれらすべての箇所を修正しなくてはならない

---
# 良いプログラムによって得られる恩恵
* 変更・修正にかかるコストが少なくて済む
* バグが少なくなる

# 悪いプログラムがもたらす弊害
* 変更・修正にかかるコストがかさむ
* バグが多くなる

---
<!-- footer: ※オブジェクト指向プログラミング（今回は詳しくは触れない）を前提とする -->

# 依存性の低さとは※

* あるクラスのプログラムを変更する際、それに連動して別のクラスも修正しなければならない時、それらのクラスたちは「依存性を持つ」。
* 変更例
  * コンストラクタやメソッドの引数の変更
  * メソッドや変数の名称変更 など
* オブジェクトは別のオブジェクトとデータをやりとりするので、依存性をゼロにするということはできない。
* 依存性を最小限にすることで、変更に伴う修正必要箇所を最小化できる。

---
<!-- footer: -->

# わかりやすさ（可読性の高さ）とは
ある処理を変更したいというケースにおいて：

### プログラムがわかりやすく作られている場合
* どのファイルのどの部分を変更すればいいのかを突き止めるためのコストが少なくて済む。

### プログラムがわかりにくい場合
* 「プログラムを解読する」という手間が発生する。
  * 修正箇所を特定する手間が大きい
  * 修正に時間がかかる
  * バグが起きやすい

↓
そのプログラムについての知識がない人間がコードを読んで、それがなにをしようとしているのかを理解するまでにかかる時間を最小化することが目標。


---
# 再利用性の高さとは
ある処理のまとまりがすでに作られているとして、同じ処理/似たような処理を別の箇所でもやる必要がある場合に：

## 再利用性が高いとは
* その処理自体を必要な箇所から呼び出して利用できる。
## 利用性が低いとは
* その処理自体を使いたいところから呼び出すことができないので、該当箇所のコードがコピーペーストされて別の箇所に移植される。

↓
コピペによる増殖を防ぐことで「同じ修正をしなければならない箇所の増大」を防ぐことが目的。

---
# [実践編] 効率の良い開発をするための技術

「変更の容易なプログラムを作るための知識」をもとに、それを実際の開発の業務において実践していく際に役立つ方法論
（コツのようなもの）

---
# 遅延設計とは
* 実際の開発においては、「まだ決まってない仕様」「必要だけど抜けていた仕様」に遭遇する。それに対するための態度。
* 「ちゃんと決まるまでは先延ばしにする」ということ。

## こういうリスクを避けたい
* 未確定仕様を予測して先回りして前倒し実装したり、未確定仕様を前提にしてその先を設計したりなどすると、実際に確定した仕様が異なっていた場合に修正や削除などの巻き戻しコストが掛かる。
* 未来予測は間違う可能性が常に高い。

## 変化に備えるということ
* 予測して進めておくのではなく「コードを変更しやすく保つ」。

---
# チームのメンバーの行動を予測する
## コードの拡散
* メンバーは既存コードを模範としてコードを書く
* 再利用できないコードであるとき、メンバーはコードを複製する
* 再利用できるコードであるとき、メンバーはコードを再利用する

↓
良いコードであっても悪いコードであっても、書かれたコードは拡散していく。

## コメントのリスク
* 処理はメンテナンスされるがコメントはメンテナンスされない。
* 処理が修正された際コメントが放置されてちぐはぐになるリスクがある。不適切なコメントはコードの可読性を落とす。
* どういうケースでコメント書くのかのルールが必要。

---
# 今回の脳内マップの活用
* 例えば「デメテルの法則」という知識に触れたとする。
* その内容は「クラス関係における直接の隣人のみに話かけよう」というもの
* すると脳内マップでは以下の位置づけになる

```
クオリティの高い開発を効率良く行う
  ┗ [知識編] 変更の容易なプログラムを作るための知識
    ┗ 依存性の低さ
```

* これにより、個々の具体的な専門知識を構造的に整理して理解できるようにしたいというのが狙い。

---
# 各論技術の具体例
## 「デメテルの法則」を例に
* 「直接の隣人のみに話かけよう」という内容
* 他のオブジェクトについての詳しい知識を必要としないようにしようということ

↓
脳内マップ構造上の位置では

```
クオリティの高い開発を効率良く行う
  ┗ [知識編] 変更の容易なプログラムを作るための知識
    ┗ 依存性の低さ
```
だなと感じてもらえれば良い。

---
# デメテルの法則解説
悪い例で説明。

* 寿司屋のシステムがあるとする。
* その寿司屋ではサイドメニューとしてオレンジジュースを提供している。
* オレンジジュースにはサイズにSとMとがある。
* Sサイズのオレンジジュースは毎週水曜日に20円引きになる。

このとき「寿司屋クラス」が「オレンジジュースSサイズの水曜日の価格を取得する」というメソッドを持っているとする。

```
class SushiShop {
  public function getOrangeJuiceSsizePriceAtWednesday() {
    return $this->side_menus->orange_juice->s->price -20;
  }
}
```

---
## 依存性が高い
寿司屋クラスがこのメソッドのために知らなくてはならない知識が多い。
* サイドメニューにオレンジジュースが存在する
* オレンジジュースにはSサイズがある
* オレンジジュースSは水曜日に20円割り引かれる

寿司屋と直接関係のない以下のような変更の際に寿司屋クラスも同時に変更しなくてはならなくなる。
* オレンジジュースSの割引日の変更
* オレンジジュースSの割引額の変更
* メニューからオレンジジュースSが削除される

---
## 寿司屋の隣人は誰か
今回の設計では各オブジェクトの関係は以下のようになっていると考えられる。

```
寿司屋
  ┗ メインメニュー
    ┗ 寿司
      ┗ マグロの赤身
      ┗ …
    ┗ 蕎麦
      ┗ 天ぷらそば
  ┗ サイドメニュー
    ┗ ドリンク
      ┗ オレンジジュース
        ┗ Sサイズ
        ┗ Mサイズ
      ┗ スイカスムージー
        ┗ Lサイズ
    ┗ デザート
      ┗ スイカケーキ
```

→ 寿司屋の直接の隣人は「メインメニュー」「サイドメニュー」

---
# デメテルの法則＠寿司屋クラス

```
class SushiShop {
  public function getMainMenus(): array {
    return $this->main_menus;
  }

  public function getSideMenus(): array {
    return $this->side_menus;
  }
}
```

↓
サイドメニューからオレンジジュースが消滅しようが、寿司屋クラスを変更する必要はない。

---
# 蓄積ノウハウの実際の開発での応用例
システムを開発していて、取り組み中のイシューに書かれた要件を満たすための処理を作成しているとする。
作成中、要件定義書には書かれていないが「これをあらかじめ決めておかないと詳しい処理が作れない」という項目に気づき、クライアントに問い合わせることにするとする。
「先方からの答えはどうせこうだろう」とある程度予測が付き、それを前提としてより詳細な処理まで作ろうと思えば作れはするとする。
その段階でどこまで作ってプルリクをまとめるかをジャッジしたい。

---
## 応用可能な根拠がノウハウ体系にある

```
[目的]クオリティの高い開発を効率良く行う
  └ [実践編] 効率の良い開発をするための技術
       └ 遅延設計
```

で似たようなことを言っていたなと気づく。
↓
> * ちゃんと決まるまでは先延ばしにする
> * 予測して進めておくのではなく「コードを変更しやすく保つ」

↓
現時点では未確定事項を前提とした箇所まではプルリクを作り込まず、その代り値が流動的になりそうな箇所は変数化しておいて一箇所変更すればそれを使う箇所全部がそれに連動するようにしておく、みたいな対応を選択できる。

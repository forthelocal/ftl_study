<!-- page_number: true -->

# オブジェクト指向とは

1. 手続き型との世界観の違い
2. オブジェクト指向設計が「依存関係を設計すること」である理由
3. 設計の原則とパターン


---
## 1. 手続き型との世界観の違い
### 手続き型の世界観

世界は手続き的といえる。時の流れの中で出来事が順番に起こり、過ぎ去っていきます。

  1. 朝起きて
  2. ベッドから出て
  3. 歯を磨いて
  4. コーヒーを飲み
  5. 着替えて
  6. 会社へ向かう

物事の順序に従って、それぞれを実行するコードを書き、一つ一つを慎重につなぎ合わせていく。

---

### オブジェクト指向の世界観（1/3）

世界はオブジェクト指向ともいえる。日常には様々なオブジェクト同士の関わり合いがあります。

- 「コーヒーマシーン」が抽出した「コーヒー」が落ちるのを受け止める「マグカップ」
- 「プログラマ」とその人が座る「椅子」
- 自身の脈打つ「心臓」とその健康を保つ「エクササイズ計画」

オブジェクトはそれぞれが自身の振る舞いをもち、相互に作用します。
相互作用は予測可能なものもあるが、 「**予想不可能な相互作用**」が起こる可能性もある。

---

### オブジェクト指向の世界観（2/3）

例えばこういう「予想不可能な相互作用」も起こりうる。

```
「コーヒーマシーン」が壊れて熱い「コーヒー」が吹き出して
熱いコーヒーがかかった「プログラマ」が大声をあげる。
さらに別の「プログラマ」が驚いて「椅子」から転げ落ちる。
```

それらのオブジェクトが「壊れる」「大声を上げる」「椅子から落ちる」といった振る舞いを持つ時、そのような相互作用も起こりえます。

---

### オブジェクト指向の世界観（3/3）

もう少し実際のコードの側に倒して説明すると、

一度書かれたオブジェクト指向のコードは、予想もしない使われ方（例：驚いた「プログラマ」が「椅子」から転げ落ちる）をするかもしれないし、そうなるかは未来にならないとわからない、と言い換えられます。

このことは「あらかじめ決められた順番ではない」予測不可能な相互作用にたいして、オブジェクト指向は「柔軟性を持っている」とも言えます。

---
### まとめ
- 世界は手続き型であると同時にオブジェクト指向である
- オブジェクト指向は、部品となる「オブジェクト」同士の相互作用によってアプリケーション全体の振る舞いが決まる、という考え方。
- オブジェクト指向では予想外の相互作用も起こりえる。これは変更に対して柔軟性を持っている、と言い換えられる。

---

## 2. オブジェクト指向設計が「依存関係を設計すること」である理由
### オブジェクト指向の意味

```
オブジェクト同士の相互作用として、システムの振る舞いをとらえる
考え方
```

---
### オブジェクト指向設計の簡単な説明
オブジェクト指向設計で作られたアプリケーションはそれを構成する
*部品同士の相互作用*によって全体の振る舞いを実現する

```
例：通販サービスの「注文確定時の総額を確認する」機能

[商品] <------- [カート] <------- [注文情報]
　   (値段を教えて！）   （総額を教えて！）

```

---
### オブジェクト指向設計を構成する要素

オブジェクト：アプリケーションを構成する部品
メッセージ：オブジェクト間で行われる命令

```

[オブジェクトA] <------- [オブジェクトB]
　　　　　　   (メッセージ）

```

---


### オブジェクト指向の依存関係とは（1/2）
依存関係の意味（コトバンクより引用）

```
論理学で、ある事物の存在・状態・価値などが、他の事物によって
規定され制約される関係。
```
---

### オブジェクト指向の依存関係とは（2/2）

オブジェクト指向においては、以下のようなオブジェクト間の関係と言える

- あるオブジェクトの仕様変更が他のオブジェクトの仕様変更を強制するような関係
- あるオブジェクトの仕様を変更しようとしたとき、他のオブジェクトの仕様によって「その変更後の仕様」が制約を受けて決まるような関係

---
### あるオブジェクトの仕様変更が他のオブジェクトの仕様の変更を強制するような関係
例：

- メソッドやコンストラクタの引数が変われば（引数の数、引数のデータ型、引数のラベル、など）、それを使用している箇所で変更を行う必要がある
- プロパティの値やメソッドの返り値が変わったとき、その値を使用している箇所で処理の結果が変わったり、機能が壊れたりする
	- データ型などが変われば、修正が必要になる
	- 想定していない値に変更（新しいデータの「種類」が追加された場合など）、ロジックの前提が崩れ、修正が必要になる
- クラス名、メソッド名、プロパティ名などが変わったとき、それを使用している場所でも変更後の名前に修正する必要がある
 ...

---

### あるオブジェクトの仕様を変更しようとしたとき、他のオブジェクトの仕様によってその変更が制約を受けるような関係
例：

- メソッドの引数やプロパティにデータ型やインターフェイス（プロトコル）が指定されているとき、そのクラスの継承やインターフェイスへの準拠が必要になる
	- 行いたい変更があっても、その変更は依存先の仕様への対応が可能であったとき初めて行える（さもなければ、現在動いている機能が壊れる）

--- 
### オブジェクト間の依存関係は何故生まれるのか

オブジェクトは他のオブジェクトとメッセージのやり取りをする必要がある。

オブジェクトはメッセージを送るため「メッセージの正しい送り方」を知っている必要がある。

そのメッセージの正しい送り方とは、インターフェイスであり、コンテキストである。その仕様についての知識が依存関係を生む。

---

### オブジェクト指向設計が「依存関係を設計すること」である理由

依存関係により、オブジェクトの仕様変更は伝播し、他のオブジェクトにも変更を強いてしまう。

つまり、オブジェクト間の依存関係は、変更のコストとリスク（変更により機能が破壊される可能性）を引き上げる要因となってしまう。

「変更しやすいコード」のためには、無駄な依存関係をなくし、必要な依存関係だけを残すという、依存関係の設計が必要になる。

それがオブジェクト指向設計の目的。

___
<span style="color:red">【質問】このコードにはどんな依存関係があるか？</span>

```
// Productクラスの定義はスペースの関係上、割愛
class Cart {    
    func calculate(products: [Products]) -> Int {
        var sum: Int = 0
        products.forEach { (p) in
            sum = sum + p.price
        }
        return sum
    }
}

let product1 = Product(name: "iPhone", price: 120000)
let product2 = Product(name: "iPad", price: 80000)

let cart = Cart()
cart.calculate(products: [product1, product2])
```
---
### 答え（一部）

`Cart`クラスの`calculate`メソッドは、`Product`クラスと依存関係を持っている

- `Product`の`price`変数の名前に変更があった場合、このコードは壊れる
- サブスクリプションサービス、電話サポート、追加保証のような「値段（`price`）を持つ別のオブジェクト」の追加の要件に対応できないかもしれない
 ...

<span style="color:red">【質問】これは問題なのか？</span>

---

### 答え

この依存関係が問題になるかどうかは **「その時点の要件」** と
**「アプリケーションについての知識をどれだけ持っているか（変更の可能性を知っているのか）」** に依る。
 
---
### 依存関係がリスクになるケース

- 「現在」サブスクリプションサービスの要件がある
- 「将来的に」サブスクリプションサービスの導入が予定されており、要件の変更が高い確率で発生する

**今後、コードを修正する必要性が出てくる（かもしれない）**

---

### 依存関係がリスクにならないケース
- 「現在」サブスクリプションサービスの要件がない
- 「将来的に」もサブスクリプションサービスのような、値段を持つ別の種類の商品が導入される予定がない


コードを修正する必要性はない

---

### まとめ

- 依存関係はオブジェクトがメッセージを送る限り生まれるもの
- 依存関係はコントロールすべきものであって、不要で邪魔なものではない
- ある依存関係が不要か、無駄かどうかの判断は
	- 要件に依る
	- 将来的な変更の可能性に依る

**「何に依存させ、何に依存させないのか」その都度、判断する必要がある**
（「判断基準」は第二部で詳しく）

---
## 3. 設計の原則とパターン
### 設計の原則
- SOLID原則
- デメテルの法則
- DRY

1990年代のChidamberとKemerer、Basilらによる研究で「高品質なコード」と「これらの手法」の間に明確な相関が見られた。

2001年のLaingとColemanによる研究では、NASAのロケット科学に関するアプリケーション（1,617のクラスと500,000行のコードで構成）を対象としたが、その場合でも同様の結果が示された。

**つまり、これらの原則に従うことはオブジェクト指向設計をするうえで
合理的といえる**

---

### SOLID原則
- S（Single Responsibility）
	- 単一責任
- O（Open-Closed）
	- オープン・クローズド
- L（Liskov Substitution）
	- リスコフの置換
- I（Interface Segregation）
	- インターフェイス分離
- D（Dependency Inversion）
	- 依存性逆転

---

### DRY
- Don't Repeat Youself
- 情報の重複の生むリスク
	- 変更の困難さを増大させる
	- 透明性を減少させる
	- 不一致を生じる可能性につながる
- 単一責任、再利用性の話にもつながる（第二部で詳しく）

---

### デメテルの法則
**オブジェクトを疎結合にするためのコーディング規則**

- 最小知識の原則とも呼ばれる
	- 自分以外のオブジェクトやプロパティに対して持っている仮定を最小限にすべきであるという考え方
- 一言で「直接の隣人のみに話しかけよう（ドットは1つだけにしよう。例：`hoge.piyo()`）」とよく言われる
- オブジェクト指向においては「関数/メソッドに関するデメテルの法則」として適用される
	- （次ページ）
- デメテルの法則は必ず従わなければならないものではない
	- 法則に違反するリスクと修正コストのバランスをとって採用すべき

---

### 関数/メソッドに関するデメテルの法則
- オブジェクトが呼び出しても良いメソッド
	- 「オブジェクトそれ自身」のメソッド
	- 「メソッドの引数に渡されたオブジェクト」のメソッド
	- 「メソッドの内部でインスタンス化されたオブジェクト」のメソッド
	- 「オブジェクトを直接的に構成するオブジェクト」のメソッド（オブジェクトのインスタンス変数）

- メソッドチェーンの使用を避ける
	- `hoge.piyo.huga.foo()`のような

---

### 設計のパターン
- 1995年にいわゆるGoF（Gang of Four）によって書かれた「Design Pattern」という本に書かれた内容を指す
- 「パターン」について以下のように説明されている

```
「オブジェクト指向ソフトウェア設計において遭遇するさまざまな問題」
に対して、「簡単でかつ明瞭な解を与える」ものであり
「設計プロダクトの柔軟性、モジュール性、再利用性、および理解の
しやすさをより高める」ために使えるものである。
```
- 一般的に共通する問題に名前がつけられ、同一の解決法を示した
- コミュニケーションと共同作業が可能になった
- 初心者の乱用を招いた
	- 情熱のあまり「正しいパターン」を間違った場所に適用

*このドキュメントではデザインパターンには詳しくは触れない*

---

### まとめ
- 設計の原則と呼ばれるものがいくつか存在する
- それらを使用すると「質の高いコード」が書けるという研究が存在する
- 「質の高いコード」をかくために、それら原則に従った設計を行っていく
	- それは第二部で行う
- デザインパターンは問題に対して適切なパターンを選んで適用する必要がある

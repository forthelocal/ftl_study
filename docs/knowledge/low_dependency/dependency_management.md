# 依存関係の管理
- オブジェクト指向はオブジェクト同士の相互作用による共同作業。メッセージの送り手は受け手のことを「しっている必要」がある。
    - 「知っている」というのは、同時に依存を生む
- 依存している状態とは
    - 一方のオブジェクトに変更が加えられたとき、他方のオブジェクトも変更する必要があるならば、片方に依存しているオブジェクトがある
- 以下のものを片方のオブジェクトが知っているとき、オブジェクトの間には依存関係が存在している
    - ほかのクラスの名前：Gearは、Wheelという名前のクラスが存在することを予想している
    - self以外のどこかに送ろうとしているメッセージの名前：GearはWheelのインスタンスがdiameterに応答することを予想している
    - メッセージが要求する引数
    - それらの引数の順番
- 不必要な依存はコードの合理性を損なわせる
- 結合が強固になると、そのうちのひとつだけ再利用というのが難しくなる
    - 再利用が効かないということは、コードの複製を生み、将来的な変更が難しくなる
- 解決方法：依存オブジェクトの注入（Dependency Injection）
    - クラスという具象への依存をなくし、インターフェイスという抽象に依存させることで、依存度を下げる
        - 動的型付言語でも静的型付言語でもやっていることは同じ
- 依存の隔離（改善方法）：解決はしないが、依存関係がはっきりとし問題が起こったときの対処を楽にさせる
    - インスタンス変数の作成の隔離：
        - 隔離されたことにより、依存していることを公然になる
    - メソッドへの隔離：外部メソッドをラッパーメソッドに隔離する
        - 外部メソッドの仕様が変わるたび、その使用箇所で機能が壊される
        - DRYの原則であればある処理が2箇所以上で使われたとき行うべきだが、変更の可能性が高いときに隔離することで保険になる
- 解決方法：引数の順番への依存を取り除く
    - ハッシュ（連想配列）で引数を取る
    - 現実的にはオプションはハッシュにし、変更の可能性が低い第一、第二引数のみを指定することが多い
- 依存関係の解消や改善は常に冗長化になる：コスパを見極める
    - 自分しか使わない2つの引数を持つメソッドはどうするの？→やらなくてよいのでは。
- 外部フレームワークやライブラリの引数の順番が固定的なクラスの初期化はラッパーモジュールで隔離する
    - APIに変更があったとき、影響が限定的になる
    - 変更箇所が1箇所になるので、変更（アップデート）が容易になる
- 依存方向の選択
    - 依存関係は逆転可能
    - どこに依存させるかの基準「自分より変更されないものに依存しなさい」
        - 理由
            - あるクラスは他のクラスより要件が変わりやすい
            - 具象クラスは抽象クラスより変わる可能性が高い
            - 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ
